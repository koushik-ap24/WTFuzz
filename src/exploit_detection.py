import signal

# Produce summary to user via stdout
# Write successful payload to appropriate text file
def crash_summary(result, filename, payload):
    summary = '=' * 30 + ' PROGRAM CRASH/VULNERABILITY DETECTED ' + '=' * 30 + '\n'
    
    if result['crash_type']:
        summary += f"Crash Type: {result['crash_type']}\n"
    
    if result['vulnerability_type']:
        summary += f"Detected Vulnerability(s): {result['vulnerability_type']}\n"
    
    if result['details']:
        summary += "\nCrash Details:\n"
        for detail in result['details']:
            summary += f"- {detail}\n"
    
    summary += f"\nPayload size: {len(payload)} bytes\n"
    summary += f'Fuzzing terminated, writing payload to bad_{filename}.txt'
    print(f"{summary}\n")
    
    with open(f"../fuzzer_output/bad_{filename}.txt", "w+") as f:
        f.write(payload)
    return


# Generate fuzzing summary if a crash is detected to the user.
# Outputs the crash type, crash details and detected vulnerabilities
def crash_log(returncode, error, payload, output, filename):
    result = {
        'crash_type': None,
        'vulnerability_type': None,
        'details': []
    }
    
    signal_number = -returncode if returncode < 0 else returncode
    
    if signal_number == signal.SIGSEGV:
        result['crash_type'] = 'Segmentation Fault (SIGSEGV)'
        result['details'].append('Memory access violation')
    elif signal_number == signal.SIGABRT:
        result['crash_type'] = 'Program Abort (SIGABRT)'
        result['details'].append('Program terminated abnormally')
    elif signal_number == signal.SIGILL:
        result['crash_type'] = 'Illegal Instruction (SIGILL)'
        result['details'].append('Execution of invalid instruction')
    elif signal_number == signal.SIGFPE:
        result['crash_type'] = 'Arithmetic Exception (SIGFPE)'
        result['details'].append('Arithmetic operation error detected')
    elif signal_number == 0:
        result['crash_type'] = 'Unintended Program Output'
        result['details'].append('Program printed out non-user controlled information')
    else:
        result['crash_type'] = 'Other Error'
        result['details'].append('Undetermined crash type')
    
    error_output = error.lower()
    output_lower = output.lower()
    
    format_string_indicators = [
        '0x',                    # Memory addresses
        '(nil)',                 # Null pointers printed by %p
        'stack trace'           # Often printed when %s accesses invalid address
    ]
    
    # Stack buffer overflow patterns
    if 'stack smashing detected' in error_output:
        result['vulnerability_type'] = 'Buffer Overflow (with Stack Canary)'
        result['details'].append('Buffer protection mechanism triggered')

    if (signal_number == 0 and any(indicator in output_lower for indicator in format_string_indicators)):
        result['vulnerability_type'] = '\nFormat String Vulnerability' if (result['vulnerability_type']) else 'Format String Vulnerability'
        result['details'].append('Arbitrary memory read primative caused by unsanitised format strings')

    if (signal_number == signal.SIGSEGV):
        if (any(pattern in error_output for pattern in [
              'segmentation fault',
              'invalid memory reference',
              'memory access violation'
          ])):
            result['vulnerability_type'] = '\nAbrupt Crash with Segmentation Fault' if (result['vulnerability_type']) else 'Abrupt Crash with Segmentation Fault'
            result['details'].append('Memory access violation - possible return address corruption')
            
        if(any(indicator in output_lower for indicator in format_string_indicators)):
            result['vulnerability_type'] = '\nFormat String Vulnerability' if (result['vulnerability_type']) else 'Format String Vulnerability'
            result['details'].append('Arbitrary memory read primative caused by unsanitised format strings')
        
    # Integer logic error patterns
    elif(signal_number == signal.SIGFPE and 
         any(pattern in error_output for pattern in [
              'float',
              'decimal',
              'integer',
              'nan'
          ])):
        result['vulnerability_type'] = '\nFloating-Point Exception' if (result['vulnerability_type']) else 'Floating-Point Exception'
        result['details'].append('Possible floating-point exception')
    
    return crash_summary(result, filename, payload)